---
title: XTQL Transactions
---

XTQL transactions are submitted through `xtdb.api/submit-tx` (`xtdb.api` aliased here as `xt`).

* `(xt/submit-tx <node> <tx-ops> <opts>?)`: returns the transaction key of the submitted transaction.
** `tx-ops`: vector of link:#tx-ops[transaction operations].
* `(xt/submit-tx& <node> <tx-ops> <opts>?)`: returns a `CompletableFuture` of the transaction key.

XT submit options are an optional map of the following keys:

* `system-time`: overrides system-time for the transaction, mustn't be earlier than any previous system-time.
* `default-tz`: overrides the default time zone for the transaction.

[#tx-ops]
== Transaction operations

=== `put`

Upserts documents into the given table, optionally during the given valid time period.

`[:put <table|opts> <documents>*]`

* `table` (keyword): table to insert into
* `opts` (map):
** `:into` (keyword): table to insert into
** `:valid-from`: (timestamp): may be `nil`.
    Defaults to the current time of the transaction if not provided.
** `:valid-to`: (timestamp): may be `nil`.
    Defaults to the end-of-time if not provided.
* `documents` (maps): each must contain `:xt/id`.

=== `insert-into`

Inserts documents into a table from the given query.

`(xt/insert-into <table> <query>)`

* `table` (keyword): table to insert into.
* `query` (link:./queries[`Query`]).
** The query must return an `xt/id` column.
** To specify a valid-time range, the query may return `xt/valid-from` and/or `xt/valid-to` columns.
   If not provided, these will default as per link:#_put[`put`].

For example:

[source,clojure]
----
(xt/insert-into :users
                '(from :old-users [xt/id {:first-name given-name} {:last-name family-name}]))

;; equivalent to:
;; "INSERT INTO users SELECT xt$id, first_name AS given_name, last_name AS family_name FROM old_users"
----

=== `update`

Updates documents in a given table based on the provided query.

`[:update <opts> <args>*]`

* `opts` (map):
** `:table` (keyword, required): table to update.
** `:bind` (link:./queries#_binding_specs[`BindingSpec`], optional): select the documents to update using binding constraints.
*** If not provided, this will update every document in the table.
*** May also bind extra logic variables for use in the `:set` clause or `unify-clauses`.
** `:set` (map, keyword -> link:./queries#_expressions[`Expr`]): columns to update.
** `:unify` (link:./queries#_unify_clauses[unify clause], optional): extra clauses to unify with (e.g. to join against another table).
  See link:./queries#_unify[`unify`] for more details.

For example:

[source,clojure]
----
[:update {:table :users,
          :bind [{:email $email}, version],
          :set {:version (inc version)}}
 {:email "james@example.com"}]

;; equivalent to:
;; "UPDATE users SET version = version + 1 WHERE email = 'james@example.com'"
----

To specify a valid-time range:

[source,clojure]
----
[:update {:table :users, :valid-from <from>, :valid-to <to>, ...}
 ...]
----

with default behaviour as per link:#_put[`put`], above.

=== `delete-doc`

Deletes a document from the given table, optionally during the given valid time period.

`(xt/delete <table> <id>)`

To specify a valid-time range:

* `+(-> (xt/delete ...) (xt/starting-from <from>))+`
* `+(-> (xt/delete ...) (xt/until <to>))+`
* `+(-> (xt/delete ...) (xt/during <from> <to))+`

with default behaviour as per link:#_put[`put`], above.

=== `delete`

Deletes documents from the given table, based on the provided query.

`[:delete <opts> <args>*]`

* `opts` (map):
** `:table` (keyword, required): table to delete from.
** `:bind` (link:./queries#_binding_specs[`BindingSpec`], optional): select the documents to delete using binding constraints.
*** If not provided, this will delete every document in the table.
*** May also bind extra logic variables for use in the `unify-clauses`.
** `:unify` (link:./queries#_unify_clauses[unify clauses], optional): extra clauses to unify with (e.g. to join against another table).
  See link:./queries#_unify[`unify`] for more details.

For example:

[source,clojure]
----
[:delete {:from :users, :bind [{:email "james@example.com"}]}]

;; equivalent to:
;; "DELETE FROM users WHERE email = 'james@example.com'"


[:delete '{:from :posts, :bind [author-id]
           :unify [(from :authors [{:xt/id author-id, :email "james@example.com"}])]}]

;; equivalent to:
;; "DELETE FROM users
;;  WHERE author_id IN (SELECT author_id FROM email = 'james@example.com'")
----

To specify a valid-time range:

[source,clojure]
----
[:delete {:from :users, :valid-from <from>, :valid-to <to>, ...}
 ...]
----

with default behaviour as per link:#_put[`put`], above.

=== `erase-doc`

Irrevocably erase the document from the given table (including through system time), for all valid-time.

`[:erase <table> <id>]`

=== `erase`

Irrevocably erase the document from the given table (including through system time), based on the provided query.

`[:erase <opts> <args>*]`

* `opts` (map):
** `:table` (keyword, required): table to erase from.
** `:bind` (link:./queries#_binding_specs[BindingSpec]): select the documents to erase using binding constraints.
  May also bind extra logic variables for use in the `unify-clauses`.
** `:unify` (link:./queries#_unify_clauses[unify clauses], optional): extra clauses to unify with (e.g. to join against another table).
  See link:./queries#_unify[`unify`] for more details.

For example:
[source,clojure]
----
[:erase '{:from :users, :bind [{:email $email}]}
 {:email "james@example.com"}]

;; equivalent to:
;; "ERASE FROM users WHERE email = 'james@example.com'"


[:erase '{:from :posts,
          :bind [author-id]
          :unify [(from :authors [{:xt/id author-id, :email $email}])]}
 {:email "james@example.com"}]

;; equivalent to:
;; "ERASE FROM users
;;  WHERE author_id IN (SELECT author_id FROM email = ?)
----

Notes:

* Erase operations apply for all valid-time.

[#asserts]
=== Asserts: `assert-exists`, `assert-not-exists`

Within a transaction, `assert-exists`/`assert-not-exists` operations assert that the given query returns at least one row/no rows respectively - if not, the transaction will roll back.

`[:assert-exists <query> <args>*]`

`[:assert-not-exists <query> <args>*]`

* `query` (link:./queries[`Query`]): query to evaluate.

This can be used to enforce consistency constraints - for example, to assert that there's no user with a certain email address before adding one:

[source,clojure]
----
[[:assert-not-exists '(from :users [{:email $email}])
  {:email "james@example.com"}]
  [:put :users {:xt/id :james, :email "james@example.com", ...}]]
----

=== `call`

Call a transaction function.

`[:call <fn-id> <args>*]`

Transaction functions are defined using `:put-fn`:

[source,clojure]
----
[:put-fn :increment
 '(fn [args...]
    ...
    )]
----

Transaction functions are evaluated with the Small Clojure Interpreter (https://github.com/babashka/sci[SCI^]).
They should return a vector of other transaction operations (including invoking other transaction functions).
If they return false, or throw an exception, the transaction will be rolled back.

There are a few functions available in scope during the transaction function:

* `(q <query> <opts>?)` runs an link:./queries[XTQL]/SQL query
* `+*current-tx*+`: the current transaction being indexed.
